/**
 * @since 0.5.0
 */
import * as F from 'fluture';
import * as E from 'fp-ts/es6/Either';
import { pipeable } from 'fp-ts/es6/pipeable';
/**
 * @since 0.5.0
 */
export var URI = 'Fluture/Future';
/**
 * @since 0.6.4
 */
export var left = F.reject;
/**
 * @since 0.6.4
 */
export var right = F.resolve;
/**
 * @since 0.6.4
 */
export function leftIO(ma) {
    return F.swap(F.attempt(ma));
}
/**
 * @since 0.6.4
 */
export var rightIO = F.attempt;
/**
 * @since 0.6.4
 */
export function leftTask(ma) {
    return F.swap(F.attemptP(ma));
}
/**
 * @since 0.6.4
 */
export var rightTask = F.attemptP;
/**
 * @since 0.6.4
 */
export function orElse(onLeft) {
    return F.chainRej(onLeft);
}
/**
 * @since 0.6.4
 */
export function fold(onLeft, onRight) {
    return function (ma) { return function () { return F.promise(F.coalesce(onLeft)(onRight)(ma)).then(function (mb) { return mb(); }); }; };
}
/**
 * @since 0.6.4
 */
export var swap = F.swap;
export function futurify(f) {
    return function () {
        var args = Array.prototype.slice.call(arguments);
        return F.node(function (done) {
            var cbResolver = function (e, r) { return (e != null ? done(e) : done(null, r)); };
            f.apply(null, args.concat(cbResolver));
        });
    };
}
/**
 * @since 0.5.0
 */
export var future = {
    URI: URI,
    map: function (fa, f) { return F.map(f)(fa); },
    of: F.resolve,
    ap: function (fab, fa) { return F.ap(fa)(fab); },
    chain: function (fa, f) { return F.chain(f)(fa); },
    bimap: function (fea, f, g) { return F.bimap(f)(g)(fea); },
    mapLeft: function (fea, f) { return F.mapRej(f)(fea); },
    alt: function (fx, f) { return F.alt(f())(fx); },
    chainRec: function (a, f) {
        return (function recur(a) {
            return future.chain(f(a), E.fold(recur, F.resolve));
        })(a);
    },
    throwError: left,
    fromTask: F.attemptP,
    fromIO: F.attempt
};
/**
 * @since 0.6.4
 */
export function delay(millis) {
    return chain(F.after(millis));
}
var _a = pipeable(future), alt = _a.alt, ap = _a.ap, apFirst = _a.apFirst, apSecond = _a.apSecond, bimap = _a.bimap, chain = _a.chain, chainFirst = _a.chainFirst, flatten = _a.flatten, map = _a.map, mapLeft = _a.mapLeft, fromEither = _a.fromEither, fromOption = _a.fromOption, fromPredicate = _a.fromPredicate;
export { 
/**
 * @since 0.6.4
 */
alt, 
/**
 * @since 0.6.4
 */
ap, 
/**
 * @since 0.6.4
 */
apFirst, 
/**
 * @since 0.6.4
 */
apSecond, 
/**
 * @since 0.6.4
 */
bimap, 
/**
 * @since 0.6.4
 */
chain, 
/**
 * @since 0.6.4
 */
chainFirst, 
/**
 * @since 0.6.4
 */
flatten, 
/**
 * @since 0.6.4
 */
map, 
/**
 * @since 0.6.4
 */
mapLeft, 
/**
 * @since 0.6.4
 */
fromEither, 
/**
 * @since 0.6.4
 */
fromOption, 
/**
 * @since 0.6.4
 */
fromPredicate };

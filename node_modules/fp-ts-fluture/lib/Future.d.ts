/**
 * @since 0.5.0
 */
import * as F from 'fluture'
import * as E from 'fp-ts/lib/Either'
import { Task } from 'fp-ts/lib/Task'
import { IO } from 'fp-ts/lib/IO'
import { Alt2 } from 'fp-ts/lib/Alt'
import { Bifunctor2 } from 'fp-ts/lib/Bifunctor'
import { ChainRec2 } from 'fp-ts/lib/ChainRec'
import { Monad2 } from 'fp-ts/lib/Monad'
import { MonadThrow2 } from 'fp-ts/lib/MonadThrow'
import { MonadTask2 } from 'fp-ts/lib/MonadTask'
declare module 'fp-ts/lib/HKT' {
  interface URItoKind2<E, A> {
    'Fluture/Future': Future<E, A>
  }
}
/**
 * @since 0.5.0
 */
export declare const URI = 'Fluture/Future'
/**
 * @since 0.6.4
 */
export interface Future<E, A> extends F.FutureInstance<E, A> {}
/**
 * @since 0.6.4
 */
export declare const left: <E = never, A = never>(e: E) => Future<E, A>
/**
 * @since 0.6.4
 */
export declare const right: <E = never, A = never>(a: A) => Future<E, A>
/**
 * @since 0.6.4
 */
export declare function leftIO<E = never, A = never>(ma: IO<E>): Future<E, A>
/**
 * @since 0.6.4
 */
export declare const rightIO: <E = never, A = never>(ma: IO<A>) => Future<E, A>
/**
 * @since 0.6.4
 */
export declare function leftTask<E = never, A = never>(ma: Task<E>): Future<E, A>
/**
 * @since 0.6.4
 */
export declare const rightTask: <E = never, A = never>(ma: Task<A>) => Future<E, A>
/**
 * @since 0.6.4
 */
export declare function orElse<E, A, M>(onLeft: (e: E) => Future<M, A>): (ma: Future<E, A>) => Future<M, A>
/**
 * @since 0.6.4
 */
export declare function fold<E, A, B>(
  onLeft: (left: E) => Task<B>,
  onRight: (right: A) => Task<B>
): (ma: Future<E, A>) => Task<B>
/**
 * @since 0.6.4
 */
export declare const swap: <E, A>(ma: Future<E, A>) => Future<A, E>
/**
 * @since 0.6.4
 */
export declare function futurify<L, R>(f: (cb: (e: L | null | undefined, r?: R) => void) => void): () => Future<L, R>
export declare function futurify<A, L, R>(
  f: (a: A, cb: (e: L | null | undefined, r?: R) => void) => void
): (a: A) => Future<L, R>
export declare function futurify<A, B, L, R>(
  f: (a: A, b: B, cb: (e: L | null | undefined, r?: R) => void) => void
): (a: A, b: B) => Future<L, R>
export declare function futurify<A, B, C, L, R>(
  f: (a: A, b: B, c: C, cb: (e: L | null | undefined, r?: R) => void) => void
): (a: A, b: B, c: C) => Future<L, R>
export declare function futurify<A, B, C, D, L, R>(
  f: (a: A, b: B, c: C, d: D, cb: (e: L | null | undefined, r?: R) => void) => void
): (a: A, b: B, c: C, d: D) => Future<L, R>
export declare function futurify<A, B, C, D, E, L, R>(
  f: (a: A, b: B, c: C, d: D, e: E, cb: (e: L | null | undefined, r?: R) => void) => void
): (a: A, b: B, c: C, d: D, e: E) => Future<L, R>
/**
 * @since 0.5.0
 */
export declare type URI = typeof URI
/**
 * @since 0.5.0
 */
export declare const future: Monad2<URI> &
  Bifunctor2<URI> &
  ChainRec2<URI> &
  Alt2<URI> &
  MonadThrow2<URI> &
  MonadTask2<URI>
/**
 * @since 0.6.4
 */
export declare function delay(millis: number): <A>(ma: Future<never, A>) => Future<never, A>
declare const alt: <E, A>(that: () => Future<E, A>) => (fa: Future<E, A>) => Future<E, A>,
  ap: <E, A>(fa: Future<E, A>) => <B>(fab: Future<E, (a: A) => B>) => Future<E, B>,
  apFirst: <E, B>(fb: Future<E, B>) => <A>(fa: Future<E, A>) => Future<E, A>,
  apSecond: <E, B>(fb: Future<E, B>) => <A>(fa: Future<E, A>) => Future<E, B>,
  bimap: <E, G, A, B>(f: (e: E) => G, g: (a: A) => B) => (fa: Future<E, A>) => Future<G, B>,
  chain: <E, A, B>(f: (a: A) => Future<E, B>) => (ma: Future<E, A>) => Future<E, B>,
  chainFirst: <E, A, B>(f: (a: A) => Future<E, B>) => (ma: Future<E, A>) => Future<E, A>,
  flatten: <E, A>(mma: Future<E, Future<E, A>>) => Future<E, A>,
  map: <A, B>(f: (a: A) => B) => <E>(fa: Future<E, A>) => Future<E, B>,
  mapLeft: <E, G>(f: (e: E) => G) => <A>(fa: Future<E, A>) => Future<G, A>,
  fromEither: <E, A>(ma: E.Either<E, A>) => Future<E, A>,
  fromOption: <E>(onNone: () => E) => <A>(ma: import('fp-ts/lib/Option').Option<A>) => Future<E, A>,
  fromPredicate: {
    <E, A, B extends A>(refinement: import('fp-ts/lib/function').Refinement<A, B>, onFalse: (a: A) => E): (
      a: A
    ) => Future<E, B>
    <E_1, A_1>(predicate: import('fp-ts/lib/function').Predicate<A_1>, onFalse: (a: A_1) => E_1): (
      a: A_1
    ) => Future<E_1, A_1>
  }
export {
  /**
   * @since 0.6.4
   */
  alt,
  /**
   * @since 0.6.4
   */
  ap,
  /**
   * @since 0.6.4
   */
  apFirst,
  /**
   * @since 0.6.4
   */
  apSecond,
  /**
   * @since 0.6.4
   */
  bimap,
  /**
   * @since 0.6.4
   */
  chain,
  /**
   * @since 0.6.4
   */
  chainFirst,
  /**
   * @since 0.6.4
   */
  flatten,
  /**
   * @since 0.6.4
   */
  map,
  /**
   * @since 0.6.4
   */
  mapLeft,
  /**
   * @since 0.6.4
   */
  fromEither,
  /**
   * @since 0.6.4
   */
  fromOption,
  /**
   * @since 0.6.4
   */
  fromPredicate
}

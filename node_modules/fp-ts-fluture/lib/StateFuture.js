"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var StateT_1 = require("fp-ts/lib/StateT");
var pipeable_1 = require("fp-ts/lib/pipeable");
var F = require("./Future");
var T = StateT_1.getStateM(F.future);
/**
 * @since 0.6.5
 */
exports.URI = 'StateFuture';
/**
 * @since 0.6.5
 */
exports.evalState = T.evalState;
/**
 * @since 0.6.5
 */
exports.execState = T.execState;
/**
 * @since 0.6.5
 */
function left(e) {
    return exports.fromFuture(F.left(e));
}
exports.left = left;
/**
 * @since 0.6.5
 */
exports.right = T.of;
/**
 * @since 0.6.5
 */
function rightTask(ma) {
    return exports.fromFuture(F.rightTask(ma));
}
exports.rightTask = rightTask;
/**
 * @since 0.6.5
 */
function leftTask(me) {
    return exports.fromFuture(F.leftTask(me));
}
exports.leftTask = leftTask;
/**
 * @since 0.6.5
 */
exports.fromFuture = T.fromM;
/**
 * @since 0.6.5
 */
function rightIO(ma) {
    return exports.fromFuture(F.rightIO(ma));
}
exports.rightIO = rightIO;
/**
 * @since 0.6.5
 */
function leftIO(me) {
    return exports.fromFuture(F.leftIO(me));
}
exports.leftIO = leftIO;
/**
 * @since 0.6.5
 */
exports.rightState = T.fromState;
/**
 * @since 0.6.5
 */
function leftState(me) {
    return function (s) { return F.left(me(s)[0]); };
}
exports.leftState = leftState;
/**
 * @since 0.6.5
 */
function orElse(f) {
    return function (ma) { return function (c) {
        return pipeable_1.pipe(ma(c), F.orElse(function (e) { return f(e)(c); }));
    }; };
}
exports.orElse = orElse;
/**
 * @since 0.6.5
 */
exports.get = T.get;
/**
 * @since 0.6.5
 */
exports.put = T.put;
/**
 * @since 0.6.5
 */
exports.modify = T.modify;
/**
 * @since 0.6.5
 */
exports.gets = T.gets;
/**
 * @since 0.6.5
 */
function fromEitherK(f) {
    return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return fromEither(f.apply(void 0, a));
    };
}
exports.fromEitherK = fromEitherK;
/**
 * @since 0.6.5
 */
function chainEitherK(f) {
    return chain(fromEitherK(f));
}
exports.chainEitherK = chainEitherK;
/**
 * @since 0.6.5
 */
function fromFutureK(f) {
    return function () {
        var a = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            a[_i] = arguments[_i];
        }
        return exports.fromFuture(f.apply(void 0, a));
    };
}
exports.fromFutureK = fromFutureK;
/**
 * @since 0.6.5
 */
function chainFutureK(f) {
    return chain(fromFutureK(f));
}
exports.chainFutureK = chainFutureK;
/**
 * @since 0.6.5
 */
exports.stateFuture = {
    URI: exports.URI,
    map: T.map,
    of: exports.right,
    ap: T.ap,
    chain: T.chain,
    throwError: left,
    alt: function (fx, f) { return function (c) {
        return pipeable_1.pipe(fx(c), F.alt(function () { return f()(c); }));
    }; },
    bimap: function (fea, f, g) { return function (c) {
        return pipeable_1.pipe(fea(c), F.bimap(f, function (_a) {
            var a = _a[0], c = _a[1];
            return [g(a), c];
        }));
    }; },
    mapLeft: function (fea, f) { return function (c) { return pipeable_1.pipe(fea(c), F.mapLeft(f)); }; },
    fromIO: rightIO,
    fromTask: rightTask
};
var _a = pipeable_1.pipeable(exports.stateFuture), alt = _a.alt, ap = _a.ap, apFirst = _a.apFirst, apSecond = _a.apSecond, bimap = _a.bimap, chain = _a.chain, chainFirst = _a.chainFirst, flatten = _a.flatten, map = _a.map, mapLeft = _a.mapLeft, filterOrElse = _a.filterOrElse, fromEither = _a.fromEither, fromOption = _a.fromOption, fromPredicate = _a.fromPredicate;
exports.alt = alt;
exports.ap = ap;
exports.apFirst = apFirst;
exports.apSecond = apSecond;
exports.bimap = bimap;
exports.chain = chain;
exports.chainFirst = chainFirst;
exports.flatten = flatten;
exports.map = map;
exports.mapLeft = mapLeft;
exports.filterOrElse = filterOrElse;
exports.fromEither = fromEither;
exports.fromOption = fromOption;
exports.fromPredicate = fromPredicate;

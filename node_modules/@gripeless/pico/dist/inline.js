var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
import { chain as chainFluture, coalesce, both as flutureBoth, map as mapFluture, mapRej, parallel, reject, resolve } from 'fluture';
import { filter, flatten, map } from 'fp-ts/es6/Array';
import { left, right } from 'fp-ts/es6/Either';
import { identity } from 'fp-ts/es6/function';
import { pipe } from 'fp-ts/es6/pipeable';
import { blobToDataURL, download, downloadErrorToDetailedError, responseToBlob, responseToText } from './download';
import { empty as emptyErrorStack, errors as errorStackErrors, fromEithers as errorStackFromEithers, fromError as errorStackFromError, fromErrors as errorStackFromErrors, value as errorStackValue, fold as foldErrorStacks } from './error-stack';
var parallelAll = parallel(Infinity);
function isCSSStyleSheet(sheet) {
    return sheet instanceof CSSStyleSheet;
}
// Takes a non-global, non-sticky RegExp object with exactly one capturing
// group
var replaceAllAsync = function (regex, replaceFn) { return function (input) {
    if (regex.global || regex.sticky) {
        throw new TypeError('Only non-global and non-sticky ' +
            "(without the /g or /y flags) regex' can be used");
    }
    var result = regex.exec(input);
    if (result === null) {
        return resolve(emptyErrorStack(input));
    }
    var theWholeMatch = result[0];
    var firstGroup = result[1];
    if (typeof result[1] !== 'string') {
        return resolve(emptyErrorStack(input));
    }
    var start = input.substring(0, result.index);
    var middleF = pipe(replaceFn(firstGroup), coalesce(errorStackFromError(firstGroup))(emptyErrorStack));
    var endF = replaceAllAsync(regex, replaceFn)(input.substring(result.index + theWholeMatch.length));
    return pipe(flutureBoth(middleF)(endF), mapFluture(function (_a) {
        var _b = __read(_a, 2), middle = _b[0], end = _b[1];
        return errorStackFromErrors(start + middle.value + end.value)(flatten([middle.errors, end.errors]));
    }));
}; };
var processStyleSheetText = function (baseURL) { return function (styleSheetText) {
    var $stylesheetStyle = document.createElement('style');
    $stylesheetStyle.appendChild(document.createTextNode(styleSheetText));
    var $fakeDocument = document.implementation.createHTMLDocument();
    $fakeDocument.head.appendChild($stylesheetStyle);
    var sheet = $stylesheetStyle.sheet;
    if (!(sheet instanceof CSSStyleSheet)) {
        var reason = 'Failed to initialize CSSStyleSheet';
        return reject({
            reason: reason,
            error: new Error(reason)
        });
    }
    return inlineURLsFromCSSRuleList(sheet.cssRules, baseURL);
}; };
var URL_REGEX = /url\(['"]?(.+?)['"]?\)/;
var inlineStyleSheetTextURLs = function (baseURL) {
    return replaceAllAsync(URL_REGEX, function (url) {
        if (url.indexOf('data:') === 0) {
            // Skip data urls
            return resolve("url(\"" + url + "\")");
        }
        var absoluteURL = new URL(url, baseURL).toString();
        return pipe(download(absoluteURL), mapRej(downloadErrorToDetailedError), chainFluture(responseToBlob), chainFluture(blobToDataURL), mapFluture(function (dataURL) { return "url(" + dataURL + ")"; }));
    });
};
var inlineURLsFromCSSRule = function (baseURL) { return function (rule) {
    // https://developer.mozilla.org/en-US/docs/Web/CSS/url()
    // "The url() function can be included as a value for background,
    // background-image, list-style, list-style-image, content, cursor,
    // border, border-image, border-image-source, mask, mask-image, src as
    // part of a @font-face block, and @counter-style/symbol"
    if (rule instanceof CSSStyleRule) {
        // We go through only the allowed properties individually rather
        // than doing a single big rule.cssText.replace(blahblah) because
        // there can be special cases like `content`, where a property
        // that's just the url() call should be replaced but when it's a
        // url() call inside of a string it should not which makes using a
        // regex-only solution unreasonable.
        //
        // 1. Find all url() calls from `rule.style[x]`
        // 2. Fetch the resources under the url()'s
        // 3. Replace with base64 fetched contents using
        //    `rule.style.setProperty`
        //
        // Modifying rule.style[x] doesn't actually update the base css
        // text, which is a shame - instead we're going to update the
        // rule.style text and then return cssText, which DOES get updated.
        var rulesThatNeedTheirURLCallsInlined = [
            'background',
            'backgroundImage',
            'listStyle',
            'listStyleImage',
            'content',
            'cursor',
            'border',
            'borderImage',
            'borderImageSource',
            'mask',
            'maskImage'
        ];
        return pipe(rulesThatNeedTheirURLCallsInlined.map(function (ruleName) {
            var ruleStyle = rule.style[ruleName];
            if (ruleStyle === '' ||
                ruleStyle === undefined) {
                return resolve([]);
            }
            return pipe(inlineStyleSheetTextURLs(baseURL)(ruleStyle), mapFluture(function (_a) {
                var errors = _a.errors, value = _a.value;
                // fp gods please spare me again
                rule.style[ruleName] = value;
                return errors;
            }));
        }), parallelAll, mapFluture(flatten), mapFluture(function (e) {
            // Needs to be a thunk to let the rule.cssText update
            return errorStackFromErrors(rule.cssText)(e);
        }));
    }
    else if (rule instanceof CSSFontFaceRule) {
        // Setting `src` in a @font-face declaration is not supported in
        // Firefox, we unfortunately have to replace things manually
        return inlineStyleSheetTextURLs(baseURL)(rule.cssText);
    }
    else if (rule instanceof CSSMediaRule) {
        if (window.matchMedia(rule.media.mediaText).matches) {
            return inlineURLsFromCSSRuleList(rule.cssRules, baseURL);
        }
        else {
            return resolve(emptyErrorStack(''));
        }
    }
    else if (rule instanceof CSSImportRule) {
        // Download the referenced stylesheet recursively
        return pipe(download(rule.href), mapRej(downloadErrorToDetailedError), chainFluture(responseToText), chainFluture(processStyleSheetText(rule.href)));
    }
    else if (rule instanceof CSSPageRule) {
        // Library is not used in print contexts - safe to ignore.
        return resolve(emptyErrorStack(rule.cssText));
    }
    return resolve(emptyErrorStack(rule.cssText));
}; };
var inlineURLsFromCSSRuleList = function (cssRules, baseURL) {
    return pipe(Array.from(cssRules), map(inlineURLsFromCSSRule(baseURL)), map(coalesce(function (x) {
        return errorStackFromErrors('')([x]);
    })(identity)), parallelAll, mapFluture(foldErrorStacks(function (a, b) { return a + "\n" + b; }, '')));
};
// Cross-origin stylesheets cannot be read from directly, download any
// stylesheet that's not inline.
var extractStylesFromCSSStyleSheet = function (baseURL) { return function (styleSheet) {
    return pipe(styleSheet.href
        ? pipe(download(styleSheet.href), mapRej(downloadErrorToDetailedError), chainFluture(responseToText))
        : resolve(Array.from(styleSheet.cssRules)
            .map(function (rule) { return rule.cssText; })
            .join('\n')), chainFluture(processStyleSheetText(styleSheet.href || baseURL)));
}; };
var extractStylesFromStyleSheets = function (styleSheets, baseURL) {
    return pipe(Array.from(styleSheets), filter(isCSSStyleSheet), map(extractStylesFromCSSStyleSheet(baseURL)), map(coalesce(errorStackFromError(''))(identity)), parallelAll);
};
var inlineExternalStylesheets = function (container) {
    return pipe(extractStylesFromStyleSheets(container.parentWindow.document.styleSheets, container.parentWindow.window.location.href), mapFluture(function (stacks) {
        var e_1, _a;
        try {
            for (var _b = __values(pipe(stacks, map(errorStackValue))), _c = _b.next(); !_c.done; _c = _b.next()) {
                var styleContents = _c.value;
                var $style = container.parentWindow.document.createElement('style');
                $style.appendChild(container.parentWindow.document.createTextNode(styleContents));
                container.tree.head.appendChild($style);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        var errors = pipe(stacks, map(errorStackErrors), flatten);
        return errorStackFromErrors(container)(errors);
    }));
};
// Inline all images on the page (improvement: can only
// inline *visible* images for potentially less network
// strain if cache doesn't work)
var inlineImages = function (container) {
    return pipe(Array.from(container.tree.html.querySelectorAll('img')), map(function ($image) {
        return pipe(download($image.src), mapRej(downloadErrorToDetailedError), chainFluture(responseToBlob), chainFluture(blobToDataURL), mapFluture(function (dataURL) {
            // please don't hurt me fp gods
            $image.src = dataURL;
            return dataURL;
        }), coalesce(left)(right));
    }), parallelAll, mapFluture(errorStackFromEithers(container)));
};
export var inlineExternalResources = function (container) {
    return pipe(inlineImages(container), chainFluture(function (stack) {
        // Improvement: `errorStack.chain`
        return pipe(inlineExternalStylesheets(errorStackValue(stack)), mapFluture(function (secondStack) {
            return errorStackFromErrors(errorStackValue(secondStack))(flatten([
                errorStackErrors(stack),
                errorStackErrors(secondStack)
            ]));
        }));
    }));
};

// Mark <canvas>, <input> and <textarea> elements with
// unique id's so that their state can be later copied into
// a clone
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
import { zip } from 'fp-ts/es6/Array';
var PICO_CLONE_ID_KEY = 'picocloneid';
var id = function () {
    return Math.random()
        .toString(32)
        .substring(2);
};
function isHTMLElement(element) {
    return element instanceof HTMLElement;
}
function isHTMLOrSVGElement(element) {
    return (element instanceof HTMLElement ||
        element instanceof SVGElement);
}
var defaultNaN = function (defaultTo) { return function (value) {
    return isNaN(value) ? defaultTo : value;
}; };
// Even though this function uses `querySelectorAll('*')` it's relatively
// fast - on a page with 25k nodes (youtube) it executes in 10-15ms
var getScrolledElements = function ($target) {
    return Array.from($target.querySelectorAll('*'))
        .filter(function ($el) { return $el.scrollTop !== 0 || $el.scrollLeft !== 0; })
        .filter(isHTMLElement);
};
var attachCloneID = function ($target) {
    var e_1, _a;
    try {
        for (var _b = __values(__spread($target.querySelectorAll('input'), $target.querySelectorAll('textarea'), $target.querySelectorAll('canvas'), getScrolledElements($target))), _c = _b.next(); !_c.done; _c = _b.next()) {
            var $element = _c.value;
            $element.dataset[PICO_CLONE_ID_KEY] = id();
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
};
var removeCloneID = function ($target) {
    var e_2, _a;
    try {
        for (var _b = __values($target.querySelectorAll("[data-" + PICO_CLONE_ID_KEY + "]")), _c = _b.next(); !_c.done; _c = _b.next()) {
            var $element = _c.value;
            if (!($element instanceof HTMLElement)) {
                console.warn('Element that had a pico clone id attached was not an HTMLElement during cleanup', $element);
                continue;
            }
            $element.removeAttribute("data-" + PICO_CLONE_ID_KEY);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
};
var cloneCanvases = function (container) {
    var e_3, _a;
    var _loop_1 = function ($clonedCanvas) {
        var cloneId = $clonedCanvas.dataset[PICO_CLONE_ID_KEY];
        if (cloneId === undefined) {
            console.warn('Failed to get clone id from cloned canvas', $clonedCanvas);
            return "continue";
        }
        var $originalCanvas = Array.from(container.parentWindow.document.querySelectorAll('canvas')).find(function ($original) {
            return $original.dataset[PICO_CLONE_ID_KEY] === cloneId;
        });
        if ($originalCanvas === undefined) {
            console.warn('Failed to find original canvas for cloned canvas', $clonedCanvas);
            return "continue";
        }
        var $replacementImg = container.parentWindow.document.createElement('img');
        // Since we're changing the element's name the "canvas"
        // will be untargetable by css, therefore we need to
        // clone all the style properties over manually in this
        // particular case.
        $replacementImg.style.cssText = container.parentWindow.window.getComputedStyle($originalCanvas).cssText;
        $replacementImg.src = $originalCanvas.toDataURL();
        var parent_1 = $clonedCanvas.parentNode;
        if (!parent_1) {
            console.warn('Failed to get parent of node', $clonedCanvas);
            return "continue";
        }
        parent_1.replaceChild($replacementImg, $clonedCanvas);
    };
    try {
        for (var _b = __values(container.tree.html.querySelectorAll('canvas')), _c = _b.next(); !_c.done; _c = _b.next()) {
            var $clonedCanvas = _c.value;
            _loop_1($clonedCanvas);
        }
    }
    catch (e_3_1) { e_3 = { error: e_3_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_3) throw e_3.error; }
    }
    return container;
};
// Input values set by JS don't get copied when performing a recursive
// `Node.cloneNode`, we need to set the attributes ourselves.
var cloneInputs = function (container) {
    var e_4, _a;
    var _loop_2 = function ($clonedInputOrTextarea) {
        var cloneId = $clonedInputOrTextarea.dataset[PICO_CLONE_ID_KEY];
        if (cloneId === undefined) {
            console.warn('Failed to get clone id from cloned input or textarea', $clonedInputOrTextarea);
            return "continue";
        }
        var $originalInputOrTextarea = __spread(container.parentWindow.document.querySelectorAll('input'), container.parentWindow.document.querySelectorAll('textarea')).find(function ($original) {
            return $original.dataset[PICO_CLONE_ID_KEY] === cloneId;
        });
        if ($originalInputOrTextarea === undefined) {
            console.warn('Failed to find original input or textarea for cloned input or textarea', $clonedInputOrTextarea);
            return "continue";
        }
        if ($originalInputOrTextarea instanceof
            HTMLInputElement &&
            $clonedInputOrTextarea instanceof HTMLInputElement) {
            if (($clonedInputOrTextarea.type === 'checkbox' ||
                $clonedInputOrTextarea.type === 'radio') &&
                $originalInputOrTextarea.checked) {
                // <input type="checkbox | radio" />
                $clonedInputOrTextarea.setAttribute('checked', 'checked');
            }
            else if (
            // <input type="number | text | range" />
            ['number', 'text', 'range'].indexOf($clonedInputOrTextarea.type) !== -1) {
                $clonedInputOrTextarea.setAttribute('value', $originalInputOrTextarea.value);
            }
        }
        else if ($originalInputOrTextarea instanceof
            HTMLTextAreaElement &&
            $clonedInputOrTextarea instanceof HTMLTextAreaElement) {
            // <textarea>
            var contents = container.parentWindow.document.createTextNode($originalInputOrTextarea.value);
            $clonedInputOrTextarea.innerHTML = '';
            $clonedInputOrTextarea.appendChild(contents);
        }
    };
    try {
        for (var _b = __values(__spread(container.tree.html.querySelectorAll('input'), container.tree.html.querySelectorAll('textarea'))), _c = _b.next(); !_c.done; _c = _b.next()) {
            var $clonedInputOrTextarea = _c.value;
            _loop_2($clonedInputOrTextarea);
        }
    }
    catch (e_4_1) { e_4 = { error: e_4_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_4) throw e_4.error; }
    }
    return container;
};
var cloneElementScroll = function (container, $clone) {
    var e_5, _a;
    var cloneId = $clone.dataset[PICO_CLONE_ID_KEY];
    if (cloneId === undefined) {
        console.warn('Failed to get clone id from cloned scrolled element', $clone);
        return;
    }
    var $original = container.parentWindow.document.querySelector("[data-" + PICO_CLONE_ID_KEY + " = \"" + cloneId + "\"]");
    if (!($original instanceof HTMLElement)) {
        console.warn('Failed to find original element for scrolled element', $clone);
        return;
    }
    $clone.style.position =
        $clone.style.position === 'absolute'
            ? 'absolute'
            : 'relative';
    $clone.style.overflow = 'hidden';
    $clone.style.width = $original.offsetWidth + 'px';
    $clone.style.height = $original.offsetHeight + 'px';
    var $clonedChildren = Array.from($clone.children).filter(isHTMLOrSVGElement);
    var $originalChildren = Array.from($original.children).filter(isHTMLOrSVGElement);
    if ($clonedChildren.length !== $originalChildren.length) {
        console.warn('Scrolled element has a different amount of children ' +
            'than its clone, skipping scroll emulation', $original);
        return;
    }
    var $$zippedChildren = zip($originalChildren, $clonedChildren);
    var scrollTopRemaining = $original.scrollTop;
    var scrollLeftRemaining = $original.scrollLeft;
    var lastChild;
    try {
        for (var $$zippedChildren_1 = __values($$zippedChildren), $$zippedChildren_1_1 = $$zippedChildren_1.next(); !$$zippedChildren_1_1.done; $$zippedChildren_1_1 = $$zippedChildren_1.next()) {
            var _b = __read($$zippedChildren_1_1.value, 2), $originalChild = _b[0], $clonedChild = _b[1];
            var originalChildStyles = container.parentWindow.window.getComputedStyle($originalChild);
            // Handle absolutely positioned children
            if (container.parentWindow.window.getComputedStyle($original).position === 'relative' &&
                originalChildStyles.position === 'absolute') {
                $clonedChild.style.top =
                    defaultNaN(0)(parseInt(originalChildStyles.top)) -
                        $original.scrollTop +
                        'px';
                $clonedChild.style.left =
                    defaultNaN(0)(parseInt(originalChildStyles.left)) -
                        $original.scrollLeft +
                        'px';
                // Since all relative children are now absolute, increment z-index
                // of all previously absolute children by 1 so that they're
                // still visible over
                $clonedChild.style.zIndex = (defaultNaN(0)(parseInt(originalChildStyles.zIndex)) + 1).toString();
                continue;
            }
            $clonedChild.style.position = 'absolute';
            $clonedChild.style.width = originalChildStyles.width;
            $clonedChild.style.height = originalChildStyles.height;
            if (typeof lastChild !== 'undefined') {
                var lastChildBoundingRect = lastChild.getBoundingClientRect();
                scrollTopRemaining -=
                    $originalChild.getBoundingClientRect().top -
                        lastChildBoundingRect.top;
                scrollLeftRemaining -=
                    $originalChild.getBoundingClientRect().left -
                        lastChildBoundingRect.left;
            }
            $clonedChild.style.top = -scrollTopRemaining + 'px';
            $clonedChild.style.left = -scrollLeftRemaining + 'px';
            lastChild = $originalChild;
            // const cloneChildBoundingRect = $originalChild.getBoundingClientRect()
        }
    }
    catch (e_5_1) { e_5 = { error: e_5_1 }; }
    finally {
        try {
            if ($$zippedChildren_1_1 && !$$zippedChildren_1_1.done && (_a = $$zippedChildren_1.return)) _a.call($$zippedChildren_1);
        }
        finally { if (e_5) throw e_5.error; }
    }
};
var cloneScrolls = function (container) {
    var e_6, _a;
    try {
        for (var _b = __values(getScrolledElements(container.parentWindow.html)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var $original = _c.value;
            var cloneId = $original.dataset[PICO_CLONE_ID_KEY];
            if (cloneId === undefined) {
                console.warn('Failed to get clone id from scrolled element', $original);
                continue;
            }
            var $cloned = container.tree.html.querySelector("[data-" + PICO_CLONE_ID_KEY + " = \"" + cloneId + "\"]");
            if (!($cloned instanceof HTMLElement)) {
                console.warn('Failed to find cloned element for original scrolled element', $original);
                continue;
            }
            cloneElementScroll(container, $cloned);
        }
    }
    catch (e_6_1) { e_6 = { error: e_6_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_6) throw e_6.error; }
    }
    // The above code doesn't process <html> scroll since it usually gets
    // special treatment in browsers, a simple `translate` will do
    container.tree.html.style.transform += " translate(-" + container.parentWindow.html.scrollLeft + "px, -" + container.parentWindow.html.scrollTop + "px)";
    return container;
};
var removeNodesMatchingSelectors = function (selectors) { return function ($node) {
    if ($node instanceof Element) {
        selectors.forEach(function (selector) {
            var e_7, _a;
            try {
                for (var _b = __values($node.querySelectorAll(selector)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var $child = _c.value;
                    $child.remove();
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_7) throw e_7.error; }
            }
        });
    }
}; };
// (ugly)
export var cloneBody = function (ignoredSelectors) { return function (container) {
    attachCloneID(container.parentWindow.html);
    container.tree.html.className =
        container.parentWindow.html.className;
    container.tree.html.style.cssText =
        container.parentWindow.html.style.cssText;
    // Fix for `rem` units
    container.tree.svg.style.fontSize = container.parentWindow.window.getComputedStyle(container.parentWindow.html).fontSize;
    var $clonedBody = container.parentWindow.body.cloneNode(true);
    removeNodesMatchingSelectors(ignoredSelectors)($clonedBody);
    container.tree.html.appendChild($clonedBody);
    cloneInputs(container);
    cloneCanvases(container);
    cloneScrolls(container);
    if ($clonedBody instanceof HTMLBodyElement) {
        container.tree.html.style.margin = '0';
    }
    removeCloneID(container.parentWindow.html);
    return container;
}; };

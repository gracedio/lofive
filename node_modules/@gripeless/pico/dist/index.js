import { chain as chainFluture, fork as forkFluture, map as mapFluture } from 'fluture';
import { fromEither as flutureFromEither } from 'fp-ts-fluture/es6/Future';
import { flow } from 'fp-ts/es6/function';
import { pipe } from 'fp-ts/es6/pipeable';
import { cloneBody } from './clone';
import { createContainer } from './container';
import { fromErrors as errorStackFromErrors } from './error-stack';
import { containerToPngBlob, containerToPngDataURL, containerToSVGBlob, createObjectURL } from './export';
import { inlineExternalResources } from './inline';
import { defaults as defaultOptions_, normalize as normalizeOptions } from './options';
export var defaultOptions = defaultOptions_;
var generateExport = function ($window, options) {
    return pipe(
    // Create container where we'll store extracted
    // information about the window (which could fail) in
    createContainer($window), flutureFromEither, 
    // Clone existing window data into a container,
    // including filling out <input>'s, copying <canvas>
    // elements, etc.  mapEither(cloneBody),
    mapFluture(cloneBody(options.ignore)), 
    // Inline external stylesheets, images, fonts as data
    // URL's inside of the copied tree
    chainFluture(inlineExternalResources));
};
export var objectURLFluture = function ($window, options) {
    return pipe(generateExport($window, options), 
    // Export tree into a png object URL and return it
    // together with all accumulated errors
    chainFluture(function (_a) {
        var container = _a.value, errors = _a.errors;
        return pipe(containerToPngBlob(container), chainFluture(flow(createObjectURL, flutureFromEither)), mapFluture(function (objectURL) {
            return errorStackFromErrors(objectURL)(errors);
        }));
    }));
};
export var svgObjectURLFluture = function ($window, options) {
    return pipe(generateExport($window, options), 
    // Export tree into a object URL containing SVG data and
    // return it together with all accumulated errors
    chainFluture(function (_a) {
        var container = _a.value, errors = _a.errors;
        return pipe(containerToSVGBlob(container), chainFluture(flow(createObjectURL, flutureFromEither)), mapFluture(function (objectURL) {
            return errorStackFromErrors(objectURL)(errors);
        }));
    }));
};
export var dataURLFluture = function ($window, options) {
    return pipe(generateExport($window, options), 
    // Export tree into a png object URL and return it
    // together with all accumulated errors
    chainFluture(function (_a) {
        var container = _a.value, errors = _a.errors;
        return pipe(containerToPngDataURL(container), mapFluture(function (objectURL) {
            return errorStackFromErrors(objectURL)(errors);
        }));
    }));
};
var promisifyExport = function (fn) { return function ($window, partialOptions) {
    if (partialOptions === void 0) { partialOptions = {}; }
    return new Promise(function (res, rej) {
        return pipe(fn($window, normalizeOptions(partialOptions)), forkFluture(function (x) { return rej(x.error); })(res));
    });
}; };
export var objectURL = promisifyExport(objectURLFluture);
export var svgObjectURL = promisifyExport(svgObjectURLFluture);
export var dataURL = promisifyExport(dataURLFluture);

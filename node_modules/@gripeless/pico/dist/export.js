import { Future, chain as chainFluture, reject } from 'fluture';
import { fromEither as flutureFromEither } from 'fp-ts-fluture/es6/Future';
import { left, right } from 'fp-ts/es6/Either';
import { flow } from 'fp-ts/es6/function';
import { pipe } from 'fp-ts/es6/pipeable';
import { createElement } from './element';
import { err } from './error';
import { timeout } from './future';
import { noop } from './noop';
var serializeSVGToDataURL = function ($svg) {
    return 'data:image/svg+xml;charset=utf-8,' +
        window.encodeURIComponent(new XMLSerializer().serializeToString($svg));
};
var canvasToPngBlob = function ($canvas) {
    return Future(function (rej, res) {
        try {
            $canvas.toBlob(function (maybeBlob) {
                if (maybeBlob === null) {
                    return rej(err('Failed to get blob from canvas ' +
                        '(the returned blob is null)'));
                }
                res(maybeBlob);
            }, 'image/png', 1);
        }
        catch (_a) {
            rej(err('Failed to get blob from canvas ' +
                '(the canvas is most likely tainted)'));
        }
        return noop;
    });
};
var canvasToPngDataURL = function ($canvas) {
    try {
        return right($canvas.toDataURL('image/png', 1));
    }
    catch (_a) {
        return left(err('Failed to get data url from canvas ' +
            '(the canvas is most likely tainted)'));
    }
};
export var containerToCanvas = function (container) {
    var scalingRatio = container.parentWindow.window.devicePixelRatio || 1;
    var $canvas = createElement(container.parentWindow.document)('canvas', {
        width: container.parentWindow.window.innerWidth *
            scalingRatio,
        height: container.parentWindow.window.innerHeight *
            scalingRatio
    });
    var ctx = $canvas.getContext('2d');
    if (ctx === null) {
        return reject(err('Failed to obtain 2d canvas context'));
    }
    return timeout(2000)(Future(function (rej, res) {
        var $img = new Image();
        $img.onerror = function () {
            return rej(err("Failed to load exported <img> onto canvas"));
        };
        $img.onload = function () {
            ctx.setTransform(scalingRatio, 0, 0, scalingRatio, 0, 0);
            ctx.drawImage($img, 0, 0);
            res($canvas);
        };
        $img.src = serializeSVGToDataURL(container.tree.svg);
        return $img.remove;
    }));
};
var dataURLToBlob = function (dataURL) {
    return Future(function (rej, res) {
        fetch(dataURL)
            .then(function (x) { return x.blob(); })
            .then(res)
            .catch(function () {
            return rej(err("Failed to convert dataURL to blob (" + dataURL + ")"));
        });
        return noop;
    });
};
export var containerToSVGBlob = function (container) {
    return pipe(serializeSVGToDataURL(container.tree.svg), dataURLToBlob);
};
export var containerToPngBlob = function (container) {
    return pipe(containerToCanvas(container), chainFluture(canvasToPngBlob));
};
export var containerToPngDataURL = function (container) {
    return pipe(containerToCanvas(container), chainFluture(flow(canvasToPngDataURL, flutureFromEither)));
};
// Type safe wrapper for URL.createObjectURL. Also because this
// function creates a reference in a global object URL store,
// this function is technically impure.
export var createObjectURL = function (object) {
    try {
        return right(URL.createObjectURL(object));
    }
    catch (_a) {
        return left(err('Failed to create result object URL'));
    }
};
